(defmacro with-undotree-test-env (&rest body)
  `(with-temp-buffer
     (let (last-command undo-tree-in-region)
       (buffer-enable-undo)
       (undo-tree-mode 1)
       ,@body)))
(defun undotree-test-setup ()
  (insert "foo")
  (undo-boundary)
  (insert "bar")
  (undo-boundary)
  (undo-tree-undo)
  (undo-tree-redo))

(expectations
  (desc "normal")
  (expect "foo"
    (with-undotree-test-env
     (undotree-test-setup)
     (undo-tree-undo)
     (buffer-string)))
  (expect (non-nil)
    (with-undotree-test-env
     (undotree-test-setup)
     (let ((size (undo-tree-size buffer-undo-tree)))
       (undo-tree-undo)
       (eq size (undo-tree-size buffer-undo-tree)))))
  (desc "region undo.")
  (expect "bar"
    (with-undotree-test-env
     (undotree-test-setup)
     (goto-char 1)
     (push-mark-command 0 t)
     (goto-char 4)
     (undo-tree-undo)
     (buffer-string)
     ))
  (expect (error)
    (with-undotree-test-env
     (undotree-test-setup)
     (goto-char 1)
     (push-mark-command 0 t)
     (goto-char 4)
     (undo-tree-undo 2)))
  (desc "verify graft-tree.")
  (expect "foobar"
    (with-undotree-test-env
     (undotree-test-setup)
     (goto-char 1)
     (push-mark-command 0 t)
     (goto-char 4)
     (undo-tree-undo)                   ; region undo
     (deactivate-mark)
     (undo-tree-undo)
     (buffer-string)))
  (expect "foo"
    (with-undotree-test-env
     (undotree-test-setup)
     (goto-char 1)
     (push-mark-command 0 t)
     (goto-char 4)
     (undo-tree-undo)                   ; region undo
     (setq last-command 'undo-tree-undo)
     (undo-tree-redo)
     (deactivate-mark)
     (setq last-command nil)
     (undo-tree-undo)
     (buffer-string)))
  (expect t
    (with-undotree-test-env
     (undotree-test-setup)
     (let ((size (undo-tree-size buffer-undo-tree)))
       (goto-char 1)
       (push-mark-command 0 t)
       (goto-char 4)
       (undo-tree-undo)                 ; region undo
       (setq last-command 'undo-tree-undo)
       (undo-tree-redo)
       (deactivate-mark)
       (eq size (undo-tree-size buffer-undo-tree)))))
  (desc "region undo on start redo.")
  (expect "bar\n"
    (let (last-command undo-tree-in-region buffer-pending-undo-tree)
      (with-temp-buffer
        (buffer-enable-undo)
        (undo-tree-mode 1)
        (insert "foo\n") (undo-boundary)
        (insert "bar\n") (undo-boundary)
        (goto-char (point-min))
        (push-mark nil t t)
        (forward-line 1)
        (undo-tree-undo)
        (buffer-string))))
  (expect "foo\nbar\nbaz"
    (let (last-command undo-tree-in-region buffer-pending-undo-tree)
      (with-temp-buffer
        (buffer-enable-undo)
        (undo-tree-mode 1)
        (insert "foo\n") (undo-boundary)
        (insert "bar\n") (undo-boundary)
        (insert "baz") (undo-boundary)
        (undo-tree-undo)
        (goto-char (point-min))
        (push-mark nil t t)
        (forward-line 1)
        (undo-tree-undo)
        (setq last-command 'undo-tree-undo)
        (undo-tree-redo)
        (setq last-command nil)
        (deactivate-mark)
        (undo-tree-redo)
        (buffer-string))))
  (expect "foo\nyyy\nbaz\nqux\n"
    (let (last-command undo-tree-in-region buffer-pending-undo-tree)
      (with-temp-buffer
        (buffer-enable-undo)
        (undo-tree-mode 1)
        (insert "foo\n") (undo-boundary)
        (insert "bar\n") (undo-boundary)
        (insert "baz\n") (undo-boundary)
        (goto-char 5) (kill-line) (undo-boundary)
        (insert "xxx") (undo-boundary)
        (goto-char (point-max))
        (insert "qux\n") (undo-boundary)
        (goto-char 5) (kill-line) (undo-boundary)
        (insert "yyy") (undo-boundary)
        (undo-tree-undo 2)
        (goto-char 5)
        (push-mark nil t t)
        (forward-line 1)
        (undo-tree-redo 2)
        (buffer-string))))
  (expect (no-error)                    ; undoが無くgraftだけでも動くか？
    (with-undotree-test-env
     (insert "foo\n") (undo-boundary)
     (insert "bar\n") (undo-boundary)
     (insert "baz\n") (undo-boundary)
     (buffer-disable-undo) (buffer-enable-undo)
     (goto-char 9) (kill-line 1) (undo-boundary)
     (undo-tree-undo)
     (goto-char 9)
     (push-mark nil t t)
     (forward-line)
     (undo-tree-redo)))
  (expect "foo\nbar\nbaz\n"             ; recover branch test
    (with-undotree-test-env
     (insert "foo\n") (undo-boundary)
     (insert "bar\n") (undo-boundary)
     (insert "baz\n") (undo-boundary)
     (undo-tree-undo)
     (insert "xxx\n") (undo-boundary)
     (undo-tree-undo)
     (setf (undo-tree-node-branch (undo-tree-current buffer-undo-tree)) 1)
     (undo-tree-redo)
     (undo-tree-undo)
     (goto-char 5)
     (push-mark nil t t)
     (forward-line)
     (undo-tree-undo)
     (setq last-command 'undo-tree-undo)
     (undo-tree-redo)
     (deactivate-mark)
     (setq last-command nil)
     (undo-tree-redo)
     (buffer-string)))
  (desc "いきすぎたundoにerrorが起こるか？")
  (expect (error-message "No further undo information")
    (with-temp-buffer
      (buffer-enable-undo)
      (insert "foo ") (undo-boundary)
      (insert "bar ")
      (setq buffer-undo-tree (make-undo-tree))
      (undo-list-transfer-to-tree)
      (undo-tree-undo (uthist-count-tree-node-num))))
  (desc "discardされた時にrootのprevisousが消去されているか？")
  (expect (error-message "No further undo information")
    (with-temp-buffer
      (let ((undo-limit 50)
            (undo-strong-limit 70))
        (buffer-enable-undo)
        (insert "foo ") (undo-boundary)
        (insert "bar ") (undo-boundary)
        (insert "baz ") (undo-boundary)
        (setq buffer-undo-tree (make-undo-tree))
        (undo-list-transfer-to-tree)
        (insert "xxx ") (undo-boundary)
        (undo-tree-undo)
        (undo-tree-redo)                ;over strong limit
        (undo-tree-discard-history)
        (undo-tree-undo (uthist-count-tree-node-num)))))
  (expect t
    (with-temp-buffer
      (let ((undo-limit 50)
            (undo-strong-limit 70)
            before-size)
        (buffer-enable-undo)
        (insert "foo ") (undo-boundary)
        (insert "bar ") (undo-boundary)
        (insert "baz ") (undo-boundary)
        (setq buffer-undo-tree (make-undo-tree))
        (undo-list-transfer-to-tree)
        (insert "xxx ") (undo-boundary)
        (undo-tree-undo)
        (undo-tree-redo)                ;over strong limit
        (setq before-size (undo-tree-size buffer-undo-tree))
        (undo-tree-discard-history)
        (< (undo-tree-size buffer-undo-tree) before-size))))
  (expect t
    (prog1 t
      (ly:tap ">>> TEST END >>>" t))))
